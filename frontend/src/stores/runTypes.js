/**
 * Run Types v8
 *
 * Type definitions and enums for run state management.
 * Ensures consistent status values and structure across the store.
 *
 * @module runTypes
 */

/**
 * Valid run status values (enum-like)
 * Note: 'complete' is used instead of 'success' for clarity (terminal vs outcome)
 */
export const RunStatus = Object.freeze({
  PENDING: 'pending', // Created but not yet started
  RUNNING: 'running', // Actively processing
  COMPLETE: 'complete', // Successfully finished (alias: success)
  FAILED: 'failed', // Error or timeout
})

/**
 * Valid workflow phases
 */
export const WorkflowPhase = Object.freeze({
  STARTING: 'starting',
  SPEC: 'spec',
  PLAN: 'plan',
  EXECUTE: 'execute',
  VERIFY: 'verify',
  REPAIR: 'repair',
  COMPLETE: 'complete',
})

/**
 * Phase status values
 */
export const PhaseStatus = Object.freeze({
  PENDING: 'pending',
  RUNNING: 'running',
  COMPLETE: 'complete',
  SKIPPED: 'skipped',
})

/**
 * Phase timeout configuration (in ms)
 */
export const PhaseTimeouts = Object.freeze({
  starting: 30000, // 30s to get started
  spec: 60000, // 1min for spec
  plan: 60000, // 1min for planning
  execute: 90000, // 1.5min for execution
  verify: 120000, // 2min for verification
  repair: 120000, // 2min for repair
  default: 90000, // Default timeout
})

/**
 * Create a single phase state object
 */
export function createPhaseState() {
  return {
    status: PhaseStatus.PENDING,
    startedAt: null,
    endedAt: null,
  }
}

/**
 * Create phases object with status + timestamps per phase
 * As required by prompt: phases: {spec,plan,execute,verify,repair,complete} avec status + timestamps
 */
export function createPhases() {
  return {
    spec: createPhaseState(),
    plan: createPhaseState(),
    execute: createPhaseState(),
    verify: createPhaseState(),
    repair: createPhaseState(),
    complete: createPhaseState(),
  }
}

/**
 * Create a new RunState object
 *
 * V8 Contract (Source of Truth) - Strict Normalized Format:
 * - run_id: string
 * - conversation_id: string | null
 * - status: RunStatus - Current run status
 * - terminal: boolean - EXPLICIT terminal flag (not derived)
 * - startedAt: ISODateString - When run started
 * - lastEventAt: ISODateString - Last heartbeat timestamp
 * - endedAt: ISODateString | null - When run ended (null if not ended)
 * - phases: {[phaseName: string]: {status: PhaseStatus, startedAt: ISODateString | null, endedAt: ISODateString | null}}
 * - thinking: Array<{message: string, timestamp: ISODateString}>
 * - tools: Array<ToolCall>
 * - verification: Array<VerificationItem>
 * - watchdog: {timerId: number | null, timeoutMs: number, lastHeartbeatAt: ISODateString}
 *
 * Backend Authority:
 * - run_id is ALWAYS generated by backend
 * - Frontend NEVER creates run_id (except documented HTTP fallback)
 *
 * @param {string} runId - Unique run identifier (MUST come from backend)
 * @param {object} options - Optional initialization options
 * @returns {object} New RunState object following strict v8 contract
 */
export function createRunState(runId, options = {}) {
  const now = Date.now()
  const isoNow = new Date(now).toISOString()

  // V8: Strict normalized structure - single source of truth
  return {
    // ===== Identity (Immutable) =====
    id: runId, // V8: id alias for backward compatibility
    run_id: runId, // V8: snake_case, backend authority
    conversation_id: options.conversationId || null, // V8: snake_case

    // ===== Message References =====
    messageId: options.messageId || null, // User message ID
    assistantMessageId: options.assistantMessageId || null, // Assistant message ID (CRITICAL for streaming updates)

    // ===== Status (Explicit) =====
    status: options.status || RunStatus.RUNNING, // V8: RUNNING initially
    terminal: false, // V8: EXPLICIT terminal flag

    // ===== Timing (ISO 8601 Strings) =====
    startedAt: isoNow, // V8: ISO string (was startTime)
    lastEventAt: isoNow, // V8: ISO string (was lastEventTime)
    endedAt: null, // V8: ISO string | null (was endTime)

    // ===== Phases (Structured) =====
    phases: createPhases(), // V8: {spec,plan,execute,verify,repair,complete}

    // ===== Content =====
    thinking: [], // V8: Array<{message, timestamp}> (was thinkingLog)
    tools: [], // V8: Array (was toolCalls)
    verification: [], // V8: Array (was verificationItems)
    tokens: '', // Accumulated tokens

    // ===== Metadata =====
    currentPhase: WorkflowPhase.STARTING,
    phaseHistory: [], // Array of phase transitions
    currentIteration: 0,
    repairCycles: 0,
    error: null, // Error message if failed

    // ===== Watchdog (Complete) =====
    watchdog: {
      timerId: null, // V8: Timer ID for cleanup
      timeoutMs: PhaseTimeouts.default, // V8: Configurable timeout
      lastHeartbeatAt: isoNow, // V8: ISO timestamp
    },

    // ===== Legacy Aliases (Backward Compatibility v7.1) =====
    // REMOVED ALL GETTERS: They cause "set on proxy" errors in Pinia reactive objects
    // Use v8 properties directly: run_id, conversation_id, startedAt, lastEventAt, endedAt, thinking, tools, verification
    // Computed values can be calculated when needed:
    //   - id → use run_id directly
    //   - conversationId → use conversation_id directly
    //   - startTime → new Date(startedAt).getTime()
    //   - endTime → endedAt ? new Date(endedAt).getTime() : null
    //   - duration → endedAt ? new Date(endedAt).getTime() - new Date(startedAt).getTime() : null
    //   - isPlaceholder → status === 'pending' && !terminal
    //   - streaming → status === 'running'

    // Legacy phaseTimestamps for backward compatibility
    phaseTimestamps: {
      starting: now,
      spec: null,
      plan: null,
      execute: null,
      verify: null,
      repair: null,
      complete: null,
    },
  }
}

/**
 * Check if a status is terminal (run is finished)
 */
export function isTerminalStatus(status) {
  return status === RunStatus.COMPLETE || status === RunStatus.FAILED
}

/**
 * Check if a status is valid
 */
export function isValidStatus(status) {
  return Object.values(RunStatus).includes(status)
}

/**
 * Check if a phase is valid
 */
export function isValidPhase(phase) {
  return Object.values(WorkflowPhase).includes(phase)
}

/**
 * Get timeout for a specific phase
 */
export function getPhaseTimeout(phase) {
  return PhaseTimeouts[phase] || PhaseTimeouts.default
}

/**
 * Update phase status and timestamps (V8 normalized)
 * @param {object} run - Run state object
 * @param {string} phase - Phase name (spec, plan, execute, verify, repair, complete)
 * @param {string} status - PhaseStatus value
 * @param {object} meta - Optional metadata (message, error, etc.)
 */
export function updatePhaseStatus(run, phase, status, meta = {}) {
  if (!run.phases[phase]) {
    console.warn(`[runTypes] Unknown phase: ${phase}`)
    return
  }

  const isoNow = new Date().toISOString()

  // V8: Update phase status
  run.phases[phase].status = status

  // V8: Set startedAt when transitioning to RUNNING
  if (status === PhaseStatus.RUNNING && !run.phases[phase].startedAt) {
    run.phases[phase].startedAt = isoNow
  }

  // V8: Set endedAt when transitioning to terminal state
  if (
    (status === PhaseStatus.COMPLETE ||
      status === PhaseStatus.SKIPPED ||
      status === PhaseStatus.FAILED) &&
    !run.phases[phase].endedAt
  ) {
    run.phases[phase].endedAt = isoNow
  }

  // V8: Record phase transition in history
  run.phaseHistory.push({
    phase,
    status,
    timestamp: isoNow,
    ...meta,
  })

  // Update current phase reference
  run.currentPhase = phase

  // Update last event timestamp (heartbeat)
  run.lastEventAt = isoNow

  // Legacy: Update phaseTimestamps for backward compatibility
  if (run.phaseTimestamps && phase in run.phaseTimestamps) {
    if (!run.phaseTimestamps[phase]) {
      run.phaseTimestamps[phase] = Date.now()
    }
  }
}

/**
 * Set terminal state for a run (V8 normalized)
 * @param {object} run - Run state object
 * @param {'complete'|'error'} type - Terminal event type
 * @param {object} payload - Terminal event payload
 */
export function setTerminal(run, type, payload = {}) {
  const isoNow = new Date().toISOString()

  // V8: EXPLICIT terminal flag
  run.terminal = true

  // V8: Terminal event details
  run.terminalEvent = {
    type, // 'complete' or 'error'
    payload,
    timestamp: isoNow,
  }

  // V8: Update status
  run.status = type === 'error' ? RunStatus.FAILED : RunStatus.COMPLETE

  // V8: Set endedAt timestamp
  run.endedAt = isoNow

  // V8: Final heartbeat
  run.lastEventAt = isoNow

  // V8: Mark complete phase if success
  if (type === 'complete') {
    updatePhaseStatus(run, 'complete', PhaseStatus.COMPLETE)
  }
}

/**
 * Update watchdog heartbeat timestamp (V8)
 * @param {object} run - Run state object
 * @param {number} timeoutMs - Optional new timeout value
 */
export function updateWatchdogHeartbeat(run, timeoutMs = null) {
  if (!run.watchdog) return

  const isoNow = new Date().toISOString()
  run.watchdog.lastHeartbeatAt = isoNow

  if (timeoutMs !== null) {
    run.watchdog.timeoutMs = timeoutMs
  }

  // Also update run's lastEventAt for consistency
  run.lastEventAt = isoNow
}

/**
 * Check if run has timed out (V8)
 * @param {object} run - Run state object
 * @returns {boolean} True if run has exceeded timeout
 */
export function hasWatchdogTimeout(run) {
  if (!run.watchdog || run.terminal) return false

  const now = Date.now()
  const lastHeartbeat = new Date(run.watchdog.lastHeartbeatAt).getTime()
  const timeout = run.watchdog.timeoutMs || PhaseTimeouts.default

  return now - lastHeartbeat > timeout
}

/**
 * Get elapsed time since last heartbeat (V8)
 * @param {object} run - Run state object
 * @returns {number} Elapsed time in milliseconds
 */
export function getWatchdogElapsed(run) {
  if (!run.watchdog) return 0

  const now = Date.now()
  const lastHeartbeat = new Date(run.watchdog.lastHeartbeatAt).getTime()

  return now - lastHeartbeat
}

/**
 * Set watchdog timer ID (V8)
 * @param {object} run - Run state object
 * @param {number|null} timerId - Timer ID or null to clear
 */
export function setWatchdogTimer(run, timerId) {
  if (!run.watchdog) return

  run.watchdog.timerId = timerId
}

/**
 * Clear watchdog timer (V8)
 * @param {object} run - Run state object
 */
export function clearWatchdogTimer(run) {
  if (!run.watchdog) return

  if (run.watchdog.timerId !== null) {
    clearInterval(run.watchdog.timerId)
    run.watchdog.timerId = null
  }
}

/**
 * Fail a run due to watchdog timeout (V8)
 * @param {object} run - Run state object
 * @param {string} reason - Timeout reason message
 */
export function failRunByWatchdog(run, reason = 'Watchdog timeout') {
  setTerminal(run, 'error', {
    message: reason,
    phase: run.currentPhase,
    elapsedMs: getWatchdogElapsed(run),
    timeoutMs: run.watchdog?.timeoutMs || PhaseTimeouts.default,
  })

  // Mark current phase as failed
  if (run.phases[run.currentPhase]) {
    run.phases[run.currentPhase].status = PhaseStatus.FAILED
    run.phases[run.currentPhase].endedAt = new Date().toISOString()
  }

  run.error = reason
}

export default {
  RunStatus,
  WorkflowPhase,
  PhaseStatus,
  PhaseTimeouts,
  createRunState,
  createPhases,
  createPhaseState,
  isTerminalStatus,
  isValidStatus,
  isValidPhase,
  getPhaseTimeout,
  updatePhaseStatus,
  setTerminal,
  updateWatchdogHeartbeat,
  hasWatchdogTimeout,
  getWatchdogElapsed,
  setWatchdogTimer,
  clearWatchdogTimer,
  failRunByWatchdog,
}
